#include <iostream>
#include <vector>
#include <algorithm>
#include <sstream>
#include <fstream>
#include <limits>
using namespace std;


/**
* Auxiliary function used to sort paths first according to the lenght,
* and when they have the same length -- lexicographically. 
**/ 
bool compare_vectors( const std::vector<unsigned short int>& v1 , const std::vector<unsigned short int>& v2 )
{
	if ( v1.size() < v2.size() )return true;
	if ( v1.size() > v2.size() )return false;
	//in this case if v1.size() == v2.size(), we compare them lexicographically
	for ( size_t i = 0 ; i != v1.size() ; ++i )
	{
		if ( v1[i] < v2[i] )return true;
		if ( v2[i] < v1[i] )return false;
	}
	return false;
}//compare_vectors


/**
* This function compute a (sorted according to compare_vectors) vector of distinct paths in a graph.
* The graph is given as:
* (1) unsigned short int number_of_vertices -- indicating how many vertices there are in the graph, and
* (2) std::vector< std::vector<unsigned short int> > incidence_list -- list of incidences of elements -- either symmetric or not, depending of graph is not directed, or directed. 
* An additional parameter is maximal_path_length -- it is a cap for the maximal length of a paths that are considered. It is useful for large graphs with many paths -- in this case,
* caping the maximal length will make the computations more tractable. 
**/ 
///This function takes as an input a symmetric 
std::vector< std::vector<unsigned short int> > compute_paths_in_graph( unsigned short int number_of_vertices , std::vector< std::vector<unsigned short int> > incidence_list , unsigned maximal_path_length = std::numeric_limits<unsigned>::infinity() )
{
	bool dbg = false;
	std::vector< std::vector<unsigned short int> > result;
	result.reserve( 10*number_of_vertices );
	
	//first, put vertices to result:
	for ( unsigned short int v = 0 ; v != number_of_vertices ; ++v )
	{
		std::vector< unsigned short int > vec(1);
		vec[0] = v;
		result.push_back( vec );
	}
	
	
	//for every vertex v in the graph:
	for ( unsigned short int v = 0 ; v != number_of_vertices ; ++v )
	{
		//locate all the paths starting at v, that do not have repeated vertices:
		std::vector< std::vector< unsigned short int > > considered_paths(1);
		std::vector< unsigned short int > initial_path = {v};
		considered_paths[0] = initial_path;
		unsigned path_length = 1;
		
		while ( !considered_paths.empty() )
		{
			std::vector< std::vector< unsigned short int > > new_considered_paths;
			new_considered_paths.reserve( considered_paths.size() );
			
		    for ( size_t i = 0 ; i != considered_paths.size() ; ++i )
		    {				
				if ( dbg )
				{
					cerr << "Taking path : ";
					for ( size_t aa = 0 ; aa != considered_paths[i].size() ; ++aa )cerr << considered_paths[i][aa] << " ";
					cerr << "and try to extend it ";
				}
				//take considered_paths[i] and try to extend it;
				unsigned short int last_vertex = considered_paths[i][ considered_paths[i].size() - 1 ];
				
				if ( dbg )cerr << "in the direction of :  " << last_vertex << endl;
				
				//let us locate the neighbors of last_vertex
				for ( size_t aa = 0 ; aa != incidence_list[last_vertex].size() ; ++aa )
				{		
					if ( std::find( considered_paths[i].begin() , considered_paths[i].end() , incidence_list[last_vertex][aa] ) == considered_paths[i].end() )
					{
						if ( dbg )cerr << "Path can be extended in the direction of : " << incidence_list[last_vertex][aa] << endl;
						std::vector< unsigned short int > new_path( considered_paths[i] );
						new_path.push_back( incidence_list[last_vertex][aa] );
						new_considered_paths.push_back( new_path );
						result.push_back( new_path );
					}
				}
			}
			
			considered_paths = new_considered_paths;
			++path_length;
			if ( path_length == maximal_path_length )break;//here we have the possibility to set up the maximal considered path length -- may be useful for large graphs!
		}
	}	
	
	
	//now we trim all the paths and remove those for which first vertex > last vertex:
	std::vector< std::vector<unsigned short int> > trimmed_result;
	trimmed_result.reserve( result.size() );
	for ( size_t i = 0 ; i != result.size() ; ++i )
	{
		if ( (result[i].size() > 1) && (result[i][0] > result[i][ result[i].size()-1 ]) )
		{
			continue;	
		}
		trimmed_result.push_back( result[i] );
	}
	if ( dbg )
	{
		cerr << "result.size() : " << result.size() << endl;
		cerr << "trimmed_result.size() : " << trimmed_result.size() << endl;
	}
	
	//now sort it:
	std::sort( trimmed_result.begin() , trimmed_result.end() , compare_vectors );
	
	return trimmed_result;
}//compute_signatures_of_graph




/**
* This function takes as an input all the paths in the graph generated by compute_signatures_of_graph
* and return number of paths of different lengths -- a.k.a. graph signature. 
**/ 
std::vector< unsigned > compute_path_signatures( std::vector< std::vector<unsigned short int> >& paths )
{
	bool dbg = false;
	
	//std::sort( paths.begin() , paths.end() , compare_vectors_by_length );
	std::vector< unsigned > result;
	result.reserve( 10 );//not clear what to reserve it for...
	
	if ( paths.size() == 0 )return result;
	
	int number_of_paths = 1;
	for ( size_t i = 1 ; i != paths.size() ; ++i )
	{
		if ( paths[i].size() != paths[i-1].size() )
		{
			result.push_back( number_of_paths );
			
			if (dbg)cerr << "i : " << i << " number_of_paths : " << number_of_paths << endl;
			
			number_of_paths = 0;
		}
		++number_of_paths;
	}
	result.push_back( number_of_paths );
	
	if (dbg)
	{
		cerr << "Here are paths sorted according to length : \n";
		for ( size_t i = 0 ; i != paths.size() ; ++i )
		{
			for ( size_t aa = 0 ; aa != paths[i].size() ; ++aa )
			{
				cerr << paths[i][aa] << " ";
			}
			cerr << endl;
		}
	}
	
	return result;	
}//compute_path_signatures



/**
* The function compute_graded_paths take an unstructured list of paths and put it into
* a graded structure - in other words, a vector std::vector< std::vector< std::vector< unsigned short int > > >
* where the external vector at the position i have pahts of a length i. 
**/ 
std::vector< std::vector< std::vector< unsigned short int > > > compute_graded_paths( std::vector< std::vector<unsigned short int> >& paths )
{
	bool dbg = false;
	//std::sort( paths.begin() , paths.end() , compare_vectors_by_length );
	
	//check which paths are the longest; that will give us the external size of the output vector. 
	unsigned short int number_of_levels_of_gradation = paths[ paths.size()-1 ].size();
	
	if ( dbg )cerr << "number_of_levels_of_gradation : " << number_of_levels_of_gradation << endl;
	std::vector< std::vector< std::vector< unsigned short int > > > result( number_of_levels_of_gradation );
	
	//let us pre-reserve the paths vectors:
	for ( size_t i = 0 ; i != number_of_levels_of_gradation ; ++i )
	{
		std::vector< std::vector< unsigned short int > > v;
		v.reserve( paths.size() / number_of_levels_of_gradation );
		result[i] = v;
	}
	
	//and put the paths where they belongs:
	for ( size_t i = 0 ; i != paths.size() ; ++i )
	{
		size_t where_to_put = paths[i].size() - 1;
		result[ where_to_put ].push_back( paths[i] );
	}
	
	return result;
}//compute_graded_paths


/**
 * Procedure to read a graph from a file. The format of an inpt file is
 * as follows:
 * The format of a file is the following
 * First line contain number of vertices.
 * Next line constitute neighs of vertex 0
 * Next line constitute neighs of vertex 1
 * etc.
 * The file should NOT end with an empty line
**/ 
std::pair< unsigned short int , std::vector< std::vector<unsigned short int> > > read_graph_from_file( const char* filename )
{
	bool dbg = false;
	ifstream in;
	in.open( filename );
	unsigned short int nr_of_paths;
	std::string line;
	in >> nr_of_paths;
	std::getline(in,line);
	
	if ( dbg )cerr << "nr_of_paths : " << nr_of_paths << endl;
	
	std::vector< std::vector<unsigned short int> > neight_list;
	unsigned short int elem;
	
	while ( in.good() )
	{
		std::vector<unsigned short int> next_neigh_list;
		std::getline(in,line);
		if ( dbg )cerr << "read next line : " << line << endl;
		std::stringstream ss(line);
		while ( ss.good() )
		{
			ss >> elem;
			if (dbg)cerr << elem << " ";
			next_neigh_list.push_back( elem );
		}
		neight_list.push_back( next_neigh_list );
		if (dbg)cerr << endl;
	}
	
	
	
	return std::make_pair( nr_of_paths , neight_list );
}//read_graph_from_file




/**
* A procedure checking if a path potential_subpath of a length n-1 is a subpath of a 
* path potential_path of a length n. Retruns true if this is the case and false
* in the other case.
**/ 
bool is_subpath( std::vector<unsigned short int> potential_subpath , const std::vector<unsigned short int>& potential_path )
{
	if ( potential_subpath.size() != potential_path.size() - 1 )return false;
	
	bool same_front = true;
	bool same_rear = true;
	
	for ( size_t i = 0 ; i != potential_subpath.size() ; ++i )
	{
		if ( potential_subpath[i] != potential_path[i] )
		{
			same_front = false;
		}
		if ( potential_subpath[i] != potential_path[i+1] )
		{
			same_rear = false;
		}
	}  
	
	if (same_front || same_rear) return true;
	
	//we can also reverse potential_subpath and check again;
	std::reverse( potential_subpath.begin() , potential_subpath.end() );
	
	same_front = true;
	same_rear = true;
	
	for ( size_t i = 0 ; i != potential_subpath.size() ; ++i )
	{
		if ( potential_subpath[i] != potential_path[i] )
		{
			same_front = false;
		}
		if ( potential_subpath[i] != potential_path[i+1] )
		{
			same_rear = false;
		}
	}  
	return (same_front || same_rear);
}//is_subpath



/**
* A structure to represent a node of a poset. For internal use, it contain areferences
* to the elements above in the posed, and to those below in the poset. 
**/ 
struct poset_element_incidence
{
public:
	poset_element_incidence()
	{
		this->up = std::vector< std::pair< unsigned short int , size_t> >(0);
		this->down = std::vector< std::pair< unsigned short int , size_t> >(0);
	}
//first element is where to, second, the number of the edge. 
	std::vector< std::pair< unsigned short int , size_t> > up;
	std::vector< std::pair< unsigned short int , size_t> > down;
};

/**
* Given a sorted vector of paths, the function below create a postet. 
* The first vector from the output correspond to gradation, second to the list of elements of the same gradation. 
* poset_element_incidence highlight elements in one gradation up or down that 
* are comparable to the given elemnet. 
**/ 
std::vector< std::vector< poset_element_incidence > > create_poset( const std::vector< std::vector< std::vector< unsigned short int > > >& gr_paths )
{
	bool dbg = false;
	//first we initialize the output:
	std::vector< std::vector< poset_element_incidence > > result( gr_paths.size() );
	for ( size_t i = 0 ; i != gr_paths.size() ; ++i )
	{
		std::vector< poset_element_incidence > v( gr_paths[i].size() );
		result[i] = v;
	}
	
	size_t number_of_edge = 0;
	//for every gradation level:
	for ( size_t gr = 0 ; gr != gr_paths.size() ; ++gr )
	{
		if ( gr )
		{
			//for every element in this gradation:
			for ( size_t el = 0 ; el != gr_paths[gr].size() ; ++el )
			{
				//check elements in one level below 
				for ( size_t below = 0 ; below != gr_paths[gr-1].size() ; ++below )
				{
					//check if gr_paths[gr-1][below] is a subpath of gr_paths[gr][el]:
					if ( is_subpath( gr_paths[gr-1][below] , gr_paths[gr][el] ) )
					{
						 result[ gr-1 ][below].up.push_back( std::make_pair(el,number_of_edge) );
						 result[ gr ][el].down.push_back( std::make_pair(below,number_of_edge) );
						 ++number_of_edge;
						 if ( dbg )
						 {
							 cerr << "Path : ";
							 for ( size_t i = 0 ; i != gr_paths[gr-1][below].size() ; ++i )cerr << gr_paths[gr-1][below][i] << " ";
							 cerr << "\n is a subpath of : ";
							 for ( size_t i = 0 ; i != gr_paths[gr][el].size() ; ++i )cerr << gr_paths[gr][el][i] << " ";
							 getchar();
						 }
					}
				}
			}
		}
	}

	if ( dbg )
	{  
		for ( size_t i = 0 ; i != result.size() ; ++i )
		{
			for ( size_t j = 0 ; j != result[i].size() ; ++j )
			{
				cerr << "result[i][j].up.size() : " << result[i][j].up.size() << endl;
				cerr << "result[i][j].down.size() : " << result[i][j].down.size() << endl;
			}
		}
		getchar();
	}
	
	return result;
}//create_poset



/**
* Given an input poset 'poset' the function maximal_simplices_in_poset will return
* a list of maximal paths in the posets, i.e. a maximal chains of comparable elemnets.
* They will correspond to maximal simplices of the simplicial complex of a poset. 
* The output, in a form of std::vector< std::vector<size_t> > can be used as an 
* input to Gudhi simplex tree library.
**/ 
std::vector< std::vector<size_t> > maximal_simplices_in_poset( const std::vector< std::vector< poset_element_incidence > >& poset )
{
	bool dbg	 = false;
	std::vector< std::vector<unsigned short int> > maximal_simplices_verts;
	maximal_simplices_verts.reserve( poset.size() );
	//we start from the bottom level and try to extend each path as much as possible;
	
	std::vector< std::vector<unsigned short int> > paths_in_poset;
	paths_in_poset.reserve( 2*poset[0].size() );
	//load all edges going from level 0 to level 1;
	for ( size_t i = 0 ; i != poset[0].size() ; ++i )
	{
		
		if ( poset[0][i].up.size() != 0 )
		{
			//this path can be extended
			for ( size_t aa = 0 ; aa != poset[0][i].up.size() ; ++aa )
			{				
				std::vector<unsigned short int> pth(2);
				pth[0] = i;
				pth[1] = poset[0][i].up[aa].first; 
				paths_in_poset.push_back( pth );
			}
		}
		else
		{
			//path cannot be extended anymore, it is maximal, but since there is no path, but just a vertex, we do nothing. 
		}
	}
	size_t current_level = 1;
	while ( !paths_in_poset.empty() )
	{
		if ( dbg )
		{
			cout << "current_level : " << current_level << ", paths_in_poset.size() : " << paths_in_poset.size() << endl;
		}
		std::vector< std::vector<unsigned short int> > new_paths_in_poset;
		new_paths_in_poset.reserve( poset[0].size() );
		
		//we are currently at the level current_level and we try to extend paths from paths_in_poset to current_level+1
		for ( size_t pth = 0 ; pth != paths_in_poset.size() ; ++pth )
		{
			//find last vertex at the level current_level and try to extend it to current_level+1			
			size_t last_vertex = paths_in_poset[pth][ paths_in_poset[pth].size() - 1 ];
			if ( dbg )
			{
				cerr << "Starting with path : ";
				for ( size_t aa = 0 ; aa != paths_in_poset[pth].size() ; ++aa )cerr << paths_in_poset[pth][aa] << " ";
				cerr << endl << "last_vertex : " << last_vertex << endl;
			} 
			
			//this is a vertex at the level 'level'
			if ( poset[current_level][last_vertex].up.size() != 0 )
			{
				//if it can be extend it, extending it.
				for ( size_t ext = 0 ; ext != poset[current_level][last_vertex].up.size() ; ++ext )
				{
					std::vector<unsigned short int> ext_path( paths_in_poset[pth] );
					ext_path.push_back( poset[current_level][last_vertex].up[ext].first );
					if ( dbg ) cerr << "Extending into direction of : " << poset[current_level][last_vertex].up[ext].first << endl;
					new_paths_in_poset.push_back( ext_path );
				} 
			}
			else
			{
				if ( dbg )cerr << "Maximal path, storing.\n";  
				//if not, you have reached a maximal path. 
				maximal_simplices_verts.push_back( paths_in_poset[pth] );
			}
			if ( dbg )getchar();
		}
		paths_in_poset = new_paths_in_poset;
		++current_level;
	}
	
	if ( dbg )
	{
		cerr << "maximal_simplices_verts \n";
		for ( size_t i = 0 ; i != maximal_simplices_verts.size() ; ++i )
		{
			for ( size_t j = 0 ; j != maximal_simplices_verts[i].size() ; ++j )
			{
				cout << maximal_simplices_verts[i][j] << " ";
			}
			cout << endl;
		}
	}


	//Now we need to translate maximal_simplices_verts to maximal_simplices:
	//first initialize the vectors:
	std::vector< std::vector<size_t> > maximal_simplices( maximal_simplices_verts.size() );

	//for every path in maximal_simplices_verts:
	for ( size_t pth = 0 ; pth != maximal_simplices_verts.size() ; ++pth )
	{
		if ( maximal_simplices_verts[pth].size() == 1 )continue; //not a valid path for us.
		
		if ( dbg )
		{
			cerr << "Consider path : ";
			for ( size_t aa = 0 ; aa != maximal_simplices_verts[pth].size() ; ++aa )cerr << maximal_simplices_verts[pth][aa] << " ";
			cerr << endl;
		}
		
		std::vector<size_t> new_path( maximal_simplices_verts[pth].size()-1 );
		
		//for every two constitutive vertices in maximal_simplices_verts[pth]:
		for ( size_t ver = 1 ; ver != maximal_simplices_verts[pth].size() ; ++ver )
		{
			//we have a poset node at the level (ver-1) at the position maximal_simplices_verts[pth][ver-1]
			//joined with a poset node at the level (ver) at position maximal_simplices_verts[pth][ver].
			//we need to find a numner of edge between those two nodes. For that purpose, we take
			//poset[ver-1][ maximal_simplices_verts[pth][ver-1] ].up[aa].first and search where in this vector
			//is maximal_simplices_verts[pth][ver].
			//When we find it, we search for position maximal_simplices_verts[pth][ver].up[aa].second
			for ( size_t aa = 0 ; aa != poset[ver-1][ maximal_simplices_verts[pth][ver-1] ].up.size() ; ++aa )
			{
				if ( poset[ver-1][ maximal_simplices_verts[pth][ver-1] ].up[aa].first == maximal_simplices_verts[pth][ver] )
				{
					new_path[ver-1] = poset[ver-1][ maximal_simplices_verts[pth][ver-1] ].up[aa].second;
					continue;
				}				
			}
		}
		
		if ( dbg )
		{
			cerr << "It corresponds to path : ";
			for ( size_t aa = 0 ; aa != new_path.size() ; ++aa )cerr << new_path[aa] << " "; 
			getchar();
		}
		
		
		maximal_simplices.push_back( new_path );
		
	}

	return maximal_simplices;
}//maximal_simplices_in_poset
